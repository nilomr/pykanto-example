# Dependencies
```{r imports}

box::use(src / dirs[dirs])
box::use(compute = src / compute)
box::use(plt = src / plot)

box::use(brms[...])
box::use(readr[read_csv])
box::use(dplyr[...])
box::use(tidyr[spread, separate, gather, expand, nesting])
box::use(ggplot2[...])
box::use(scales[...])
box::use(terra[...])
box::use(geosphere[perimeter])
box::use(plyr[round_any])
box::use(ggtext[element_markdown])
box::use(tidybayes[...])
box::use(forcats[fct_relevel])
box::use(emmeans[...])
box::use(patchwork[...])
box::use(ggnewscale[...])
```



```{r import-data}
data <- read_csv(file.path(
    dirs$resources, "bird_data", "full_dataset_2020-2021.csv"
))
dyad_data <- read_csv(file.path(
    dirs$resources, "bird_data", "dyad_dataset_2020-2021.csv"
))

data <- data %>% mutate(
    sharing_index = shared / total_rep,
    age = as.factor(age)
)
dyad_data <- dyad_data %>% mutate(
    sharing_index = shared / total_rep,
    imm_status = as.factor(wytham_born_1 + wytham_born_2)
)
```


# Model definitons

```{r}
data %>% ggplot(aes(x = dispersal_distance, y = repertoire_size, color = as.factor(age))) +
    geom_boxplot() +
    geom_jitter()

data %>% ggplot(aes(x = dispersal_distance)) +
    geom_histogram()
```

# Self-similarity and dispersal
## Spatial distributiion

```{r}
selfsim_spat_f <- brmsformula(self_similarity ~ 1 +
    gp(x, y, k = 20, scale = TRUE, c = 5 / 4),
family = gaussian()
)

selfsim_spat_m <-
    brm(
        formula = selfsim_spat_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 1000,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        # sample_prior = "only",
        file = file.path(dirs$model_fits, "selfsim_spat_m"),
        file_refit = "on_change",
        control = list(adapt_delta = 0.9999, max_treedepth = 30)
    )
```

## Vs dispersal distance
```{r}

selfsim_f <- brmsformula(self_similarity ~ 1 +
    s(dispersal_distance) + (1 | father),
family = gaussian()
)

selfsim_m <-
    brm(
        formula = selfsim_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 1000,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        # sample_prior = "only",
        # file = file.path(dirs$model_fits, "selfsim_m"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 20)
    )

pp_check(selfsim_m)
conditional_effects(selfsim_m, method = "posterior_epred")
```

# Repertoire size: residents vs immigrants
## Model
```{r}

repsize_f <- brmsformula(
    repertoire_size ~ 1 +
        wytham_born + (1 | father),
    family = poisson()
)

repsize_m <-
    brm(
        formula = repsize_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 1000,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        # sample_prior = "only",
        file = file.path(dirs$model_fits, "repsize_m"),
        file_refit = "on_change",
        control = list(adapt_delta = 0.9999, max_treedepth = 30)
    )
```

## Plot
```{r}
psetts <- list(
    text.colour = "#f2f2f2",
    background.colour = "#262626", # "transparent"
    text.size = 12,
    draw1 = "#c77426",
    draw2 = "#ad3b56",
    draw3 = "#5ca5b8"
)

labelcol <- c(psetts$draw1, psetts$draw2)
```


```{r}

postpreds <- data %>%
    filter(wytham_born == wytham_born, repertoire_size == repertoire_size) %>%
    modelr::data_grid(wytham_born, father) %>%
    tidybayes::add_epred_draws(repsize_m, ndraws = 20)

postpreds %>%
    ggplot(aes(x = .epred)) +
    stat_pointinterval(
        data = postpreds, aes(color = wytham_born, x = .epred),
        point_size = 1.5, point_alpha = .5, interval_alpha = NA,
        interval_size = NA, fill = NA
    ) +
    stat_slab(
        data = postpreds, aes(color = wytham_born, x = .epred, group = .row),
        alpha = .4, size = .2, scale = 1, fill = NA
    ) +
    scale_colour_manual(
        name = "",
        labels = paste(
            "<span style='font-weight: bold !important; color:",
            labelcol,
            "'>",
            c("Immigrant", "Resident"),
            "</span>"
        ),
        values = labelcol
    ) +
    plt$settheme(
        back.fill = psetts$background.colour,
        text.size = psetts$text.size,
        text.colour = psetts$text.colour
    ) +
    guides(
        size = "none",
        color = guide_legend(override.aes = list(linetype = 0), reverse = TRUE)
    ) +
    theme(
        legend.key = element_rect(colour = NA, fill = NA),
        legend.box.background = element_blank(),
        legend.text = ggtext::element_markdown(size = 14),
        legend.position = c(.8, .8),
        axis.title.x.bottom = ggtext::element_markdown(
            colour = psetts$text.colour, size = psetts$text.size,
            margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)
        )
    ) +
    coord_cartesian(xlim = c(2, 4), ylim = c(0, 1)) +
    labs(
        x = paste0(
            "Repertoire size <br>",
            "<span style='font-weight: bold !important; color:#9e9e9e'>",
            "(posterior predicted mean)</span>"
        ),
        y = "Density",
        title = "Northness! Northness!",
        subtitle = "*A suitable subtitle*<br>"
    ) -> repsize_m_plot

ggsave(
    filename = "repsize_m_plot.png",
    plot = repsize_m_plot,
    path = dirs$figs,
    scale = 1,
    width = 13,
    height = 10,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```


# Acoustic similarity with neighbours: residents vs immigrants
## Model
```{r}

data %>% ggplot(aes(x = prop_immigrants, y = mean_ac_sim, colour = wytham_born)) +
    geom_smooth() +
    geom_point()
acsim_neighbours_f <- brmsformula(
    mean_ac_sim ~ 1 +
        wytham_born * prop_immigrants + year + (1 | father),
    family = gaussian()
)

brms::hypothesis(acsim_neighbours_m, "wytham_bornTRUE:prop_immigrants < 0", robust = TRUE)
parnames(acsim_neighbours_m)
acsim_neighbours_m <-
    brm(
        formula = acsim_neighbours_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 1000,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        # sample_prior = "only",
        file = file.path(dirs$model_fits, "acsim_neighbours_m"),
        file_refit = "on_change",
        control = list(adapt_delta = 0.9999, max_treedepth = 30)
    )
```

## Plot

```{r}


acsim_neighbours_cond_effs <- brms::conditional_effects(
    acsim_neighbours_m,
    effects = peffect,
    spaghetti = T,
    points = T,
    ndraws = 400,
    resolution = 300,
    method = "posterior_epred"
)

acsim_neighbours_df <- as.data.frame(acsim_neighbours_cond_effs[[peffect]]) %>%
    attr("spaghetti") %>%
    tibble::as_tibble()

acsim_neighbours_df %>%
    ggplot(
        aes(
            x = effect1__,
            y = estimate__,
            group = sample__,
            colour = effect2__
        )
    ) +
    geom_line(alpha = .1, size = .5) +
    scale_colour_manual(
        name = "",
        labels = paste(
            "<span style='font-weight: bold !important; color:",
            labelcol,
            "'>",
            c("Immigrant", "Resident"),
            "</span>"
        ),
        values = labelcol
    ) +
    ggnewscale::new_scale_colour() +
    geom_smooth(
        data = acsim_neighbours_df,
        aes(
            x = effect1__,
            y = estimate__,
            group = effect2__,
            color = effect2__
        ),
        method = "lm",
        alpha = .5,
        size = 1.5,
        se = FALSE
    ) +
    scale_colour_manual(
        name = "kk", labels = c("Immigrant", "Resident"),
        values = c("black", "white")
    ) +
    plt$settheme(
        back.fill = psetts$background.colour,
        text.size = psetts$text.size,
        text.colour = psetts$text.colour
    ) +
    # guides(
    #     size = "none",
    #     color = guide_legend(
    #         override.aes = list(linetype = 0),
    #         reverse = FALSE
    #     )
    # ) +
    theme(
        legend.key = element_rect(fill = NA),
        legend.box.background = element_blank(),
        legend.text = ggtext::element_markdown(size = 14),
        legend.position = c(.8, .8),
        axis.title.x.bottom = ggtext::element_markdown(
            colour = psetts$text.colour, size = psetts$text.size,
            margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)
        )
    ) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    # coord_cartesian(xlim = c(2, 4), ylim = c(0, 1)) +
    labs(
        x = "Proportion of neighbour immigrants",
        y = "Song similarity with neighbours",
        title = "Northness! Northness!",
        subtitle = "*A suitable subtitle*<br>"
    ) # -> acsim_neighbours_plot


ggsave(
    filename = "acsim_neighbours_plot.png",
    plot = acsim_neighbours_plot,
    path = dirs$figs,
    scale = 1,
    width = 13,
    height = 10,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)

repsize_m_plot
```




## Plot

```{r}
spagetti_epred_plot(selfsim_m, "dispersal_distance",
    drawcolour = "#c0732c",
    meancolour = "#deb78b", ndraws = 300,
    resolution = 400, background = "#262626"
) +
    labs(
        x = ".",
        y = ".",
        title = ".",
        subtitle = "*.*<br>"
    ) -> selfsim_m_p1

ggsave(
    filename = "selfsim_m_p1.png",
    plot = selfsim_m_p1,
    path = dirs$figs,
    scale = 1,
    width = 10,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```

```{r gp-test}

#  1 + prop_immigrants + mean_dispersal + year + (1 | father) +
# gp(x, y, k = 15, scale = TRUE, c = 5 / 4)
m_0_f <- brmsformula(sharing_index ~ 1 +
    prop_immigrants + mean_dispersal +
    s(x, y),
family = hurdle_lognormal()
)

# Density and year have no effect, removed them
m_1_f <- brmsformula(sharing_index ~ 1 +
    prop_immigrants + mean_dispersal + s(x, y),
family = hurdle_lognormal()
)

# Spatial distribution of level of song-sharing
m_2_f <- brmsformula(sharing_index ~ 1 +
    gp(x, y, k = 20, scale = TRUE, c = 5 / 4),
family = hurdle_lognormal()
)

# Spatial distribution of immigration levels
m_3_f <- brmsformula(prop_immigrants ~ 1 +
    gp(x, y, k = 20, scale = TRUE, c = 5 / 4),
family = gaussian()
)

# Spatial distribution of dispersal levels
m_3.1_f <- brmsformula(mean_dispersal ~ 1 +
    gp(x, y, k = 20, scale = TRUE, c = 5 / 4),
family = gaussian()
)

m_4_f <- brmsformula(sharing_index ~ 1 +
    prop_immigrants * wytham_born + (1 | father) +
    s(x, y),
family = hurdle_lognormal()
)

m_5_f <- brmsformula(repertoire_size ~ 1 +
    prop_immigrants + wytham_born + mean_spat_dist + year + (1 | father) +
    s(x, y),
family = gaussian()
)

m_6_f <- brmsformula(ac_sim ~ 1 +
    s(spatial_dist) + year_1 + (1 | mm(father_1, father_2)),
family = hurdle_lognormal()
)


m_7_f <- brmsformula(ac_sim ~ 1 +
    s(spatial_dist, by = imm_status) + year_1 + (1 | mm(father_1, father_2)),
family = gaussian()
)


m_8_f <- brmsformula(sharing_index ~ 1 +
    prop_immigrants + dispersal_distance * mean_dispersal +
    gp(x, y, k = 15, scale = TRUE, c = 5 / 4) +
    (1 | father),
family = gaussian()
)

m_9_f <- brmsformula(self_similarity ~ 1 +
    prop_immigrants + mean_dispersal + wytham_born + year + (1 | father) +
    s(x, y) +
    (1 | father),
family = gaussian()
)


# https://www.andrewheiss.com/blog/2022/05/09/hurdle-lognormal-gaussian-brms/#2-hurdle-lognormal-model-on-a-non-exponential-outcome
```

```{r }
get_prior(m_4_f, data = data)


m_0 <-
    brm(
        formula = m_0_f,
        data = data,
        # prior = priors,
        iter = 1000, warmup = 500,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_0"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 20)
    )

m_1 <-
    brm(
        formula = m_1_f,
        data = data,
        # prior = priors,
        iter = 3000, warmup = 500,
        chains = 4,
        cores = 4,
        seed = 444,
        backend = "cmdstanr",
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_1"),
        file_refit = "on_change",
        control = list(adapt_delta = 0.9, max_treedepth = 15)
    )

m_2 <-
    brm(
        formula = m_2_f,
        data = data,
        # prior = priors,
        iter = 1500, warmup = 500,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_2"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 20)
    )

m_3 <-
    brm(
        formula = m_3_f,
        data = data,
        # prior = priors,
        iter = 1500, warmup = 500,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_3"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 20)
    )

m_3.1 <-
    brm(
        formula = m_3.1_f,
        data = data,
        # prior = priors,
        iter = 2000, warmup = 500,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_3.1"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 20)
    )

priors <- c(
    prior(normal(0, 0.1), class = "b", coef = "prop_immigrants"),
    prior(normal(0, 0.1), class = "b", coef = "wytham_bornTRUE")
)


m_4 <-
    brm(
        formula = m_4_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 600,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_4"),
        file_refit = "never",
        control = list(adapt_delta = 0.9999, max_treedepth = 20)
    )

m_5 <-
    brm(
        formula = m_5_f,
        data = data,
        # prior = priors,
        iter = 4000, warmup = 600,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_5"),
        file_refit = "never",
        control = list(adapt_delta = 0.99, max_treedepth = 20)
    )


m_6 <-
    brm(
        formula = m_6_f,
        data = dyad_data,
        # prior = priors,
        iter = 2000, warmup = 600,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_6"),
        file_refit = "never",
        control = list(adapt_delta = 0.99, max_treedepth = 20)
    )

m_7 <-
    brm(
        formula = m_7_f,
        data = dyad_data,
        # prior = priors,
        iter = 3000, warmup = 600,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_7"),
        file_refit = "never",
        control = list(adapt_delta = 0.999, max_treedepth = 15)
    )

m_9 <-
    brm(
        formula = m_9_f,
        data = data,
        # prior = priors,
        iter = 1000, warmup = 600,
        chains = 4,
        cores = 4,
        seed = 444,
        sample_prior = FALSE,
        file = file.path(dirs$model_fits, "m_9"),
        file_refit = "never",
        control = list(adapt_delta = 0.99, max_treedepth = 15)
    )
```


```{r}

pp_check(m_0, ndraws = 100)
pp_check(m_1, ndraws = 100)
pp_check(m_4, ndraws = 100)
pp_check(m_6, ndraws = 100)
pp_check(m_7, ndraws = 100)

conditional_effects(m_1)
conditional_effects(m_4)
conditional_effects(m_6)
conditional_effects(m_7)


me_loss_prior1 <- conditional_effects(
    m_0,
    re_formula = NULL, method = "predict"
)

p0 <- plot(me_loss_prior1, ncol = 5, points = TRUE, plot = FALSE)
p0$dev + ggtitle("Prior predictive distributions")
```
# Plot model outcomes

## Mean and sd pp check
```{r pp-checks}

# Plots for model 3

# Mean and sd
pp3 <- pp_check(m_3, type = "stat_2d")
pp_m3_data <- pp3$data %>%
    mutate(variable = gsub("_.*", "\\1", variable)) %>%
    rename(mean = value, sd = value2) %>%
    arrange(desc(variable))

ycoords <- pp_m3_data %>% filter(variable == "y")
y_min <- min(pp_m3_data$sd)
y_max <- max(pp_m3_data$sd)
x_min <- min(pp_m3_data$mean)
x_max <- max(pp_m3_data$mean)


pp_m3_data %>%
    ggplot(aes(
        x = mean, y = sd, alpha = variable,
        color = variable, size = variable
    )) +
    geom_point() +
    geom_segment(
        data = ycoords, aes(xend = mean, yend = -Inf),
        size = .5, linetype = "dashed"
    ) +
    geom_segment(
        data = ycoords, aes(xend = -Inf, yend = sd),
        size = .5, linetype = "dashed"
    ) +
    scale_color_manual("*T = (mean, sd)*",
        values = c("#c5640a", "#5c94a5"),
        labels = c("*T(y)*", "*T(y rep)*")
    ) +
    scale_alpha_manual(values = c(1, .07)) +
    scale_size_manual(values = c(3, 1)) +
    scale_y_continuous(breaks = round(seq(f = y_min, t = y_max, by = .2),
        digits = 1
    )) +
    scale_x_continuous(breaks = round(seq(f = x_min, t = x_max, by = .2),
        digits = 1
    )) +
    guides(
        alpha = "none",
        size = "none",
        color = guide_legend(override.aes = list(linetype = 0))
    ) +
    labs(
        title = "Graphical posterior predictive check",
        subtitle = "*repertoire_size ~
1 + immigrant + sampling_eff + year + s(x, y) + (1 | bird_id)*\n\n",
        caption = ""
    ) +
    theme(
        legend.text = element_markdown(family = "Times"),
        legend.title = element_markdown(family = "Times"),
        aspect.ratio = 1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(size = 12),
        plot.title = element_text(size = 14, face = "bold"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(size = 8, colour = "#363636"),
        plot.caption = element_text(size = 8, hjust = 0),
        plot.caption.position = "plot"
    ) -> pp3_plot


ggsave(
    pp3_plot,
    path = dirs$figs,
    filename = "posterior_pred_m_3.png",
    width = 14,
    height = 12,
    units = "cm",
    dpi = 350
)
```

```{r }
pp_check(m_3, ndraws = 100)
pp_check(m_3, type = "stat_2d")
plot(m_3)
plot(m_1)
conditional_effects(m_3)
# Extract conditional effects of spatial term conditioning on year:
conditional_effects(m_4,
    plot = TRUE,
    effects = "x:y",
    surface = TRUE,
    resolution = 50,
    conditions = make_conditions(m_4, vars = "year")
)



conditional_effects(m_4)
```
# Extract variance components

```{r variance comp}

VarCorr(m_0)
```
## Plot cond effects

```{r}
m_5 %>%
    emmeans(~wytham_born,
        var = "wytham_born",
        at = list(wytham_born = c(TRUE, FALSE)),
        epred = TRUE
    ) %>%
    gather_emmeans_draws() %>%
    ggplot(aes(x = wytham_born, y = .value)) +
    stat_interval(size = 5) +
    scale_color_manual(values = colorspace::lighten("#00709c", c(0.95, 0.7, 0.4))) +
    # scale_y_continuous(labels = label_comma()) +
    labs(
        x = "wytham_born", y = "Proportion shared songs",
        subtitle = "Expected values from mu and hu parts (epred = TRUE)",
        fill = "Credible interval"
    ) +
    theme(legend.position = "bottom")

m_6 %>%
    emmeans(~spatial_dist,
        var = "spatial_dist",
        at = list("spatial_dist" = seq(0, 4000, 100)),
        epred = TRUE
    ) %>%
    gather_emmeans_draws() %>%
    ggplot(aes(x = spatial_dist, y = .value)) +
    stat_lineribbon(size = 1, color = "darkorange") +
    scale_fill_manual(values = colorspace::lighten("darkorange", c(0.95, 0.7, 0.4))) +
    # scale_y_continuous(labels = label_comma()) +
    labs(
        x = "spatial_dist", y = "Proportion shared songs",
        subtitle = "Expected values from mu and hu parts (epred = TRUE)",
        fill = "Credible interval"
    ) +
    globtheme +
    theme(legend.position = "bottom")

m_7 %>%
    emmeans(~ spatial_dist:imm_status,
        var = "spatial_dist:imm_status",
        at = list("spatial_dist:imm_status" = seq(0, 1, 2)),
        epred = TRUE
    ) %>%
    gather_emmeans_draws() %>%
    ggplot(aes(x = spatial_dist, y = .value)) +
    stat_lineribbon(size = 1, color = "darkorange") +
    scale_fill_manual(values = colorspace::lighten("darkorange", c(0.95, 0.7, 0.4))) +
    # scale_y_continuous(labels = label_comma()) +
    labs(
        x = "spatial_dist", y = "Proportion shared songs",
        subtitle = "Expected values from mu and hu parts (epred = TRUE)",
        fill = "Credible interval"
    ) +
    globtheme +
    theme(legend.position = "bottom")

m_0 |>
    emmeans(~prop_immigrants,
        var = "prop_immigrants", dpar = "mu",
        regrid = "response", tran = "log", type = "response",
        at = list(prop_immigrants = seq(0, 1, 1))
    ) |>
    gather_emmeans_draws() |>
    mutate(.value = exp(.value)) |>
    ggplot(aes(x = prop_immigrants, y = .value)) +
    stat_lineribbon(size = 1, color = "darkorange") +
    scale_fill_manual(values = colorspace::lighten("darkorange", c(0.95, 0.7, 0.4))) +
    scale_y_continuous(labels = label_comma()) +
    labs(
        x = "prop_immigrants", y = "prop shared songs",
        subtitle = "Regular part of the model (dpar = \"mu\")",
        fill = "Credible interval"
    ) +
    theme(legend.position = "bottom")
```

# Plots

## Plot similarity vs distance


```{r}
# get conditional effects
m_6_cond_effs <- conditional_effects(
    m_7,
    effects = "spatial_dist:imm_status",
    spaghetti = T,
    points = T,
    ndraws = 30,
    resolution = 20,
    method = "fitted"
)
m_6_df <- as.data.frame(m_6_cond_effs$`spatial_dist:imm_status`)
```


```{r}
text_colour <- "#f2f2f2"

attr(m_6_df, "spaghetti") %>%
    ggplot() +
    geom_line(aes(
        x = effect1__,
        y = estimate__,
        group = sample__,
        colour = effect2__,
    ), alpha = .2, size = .4) +
    geom_smooth(
        # smooth jagged mean line (change to geom_line
        # to see that it has no effect otherwise)
        data = m_6_df,
        aes(
            x = effect1__,
            y = estimate__,
        ),
        alpha = 1,
        size = 2,
        colour = "#159765"
    ) +
    theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = text_colour, fill = NA, size = 1),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(colour = text_colour),
        axis.text.y = element_text(colour = text_colour),
        text = element_text(size = 8),
        plot.title = element_text(size = 14, face = "bold", colour = text_colour),
        plot.title.position = "panel",
        plot.subtitle = element_markdown(size = 8, colour = text_colour),
        plot.caption = element_text(size = 8, hjust = 0),
        plot.caption.position = "plot",
        legend.key.width = unit(0.5, "cm"),
        legend.position = c(.9, .75),
        legend.background = element_rect(fill = "transparent", color = NA),
        legend.box.background = element_rect(fill = "transparent", color = NA),
        legend.text = element_text(color = text_colour),
        legend.title = element_text(color = text_colour),
        legend.key = element_blank(),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA)
    ) +
    guides(
        size = "none",
    ) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(
        x = NULL,
        y = NULL,
        title = "Levels of postnatal dispersal across space",
        subtitle = "*Posterior conditional effects of spatial predictor*<br>"
        # caption = "\nOther information"
    ) -> acsim_vs_dist


ggsave(
    filename = "acsim_vs_dist_m7.png",
    plot = acsim_vs_dist,
    path = dirs$figs,
    scale = 1,
    width = 13,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```

## Plot sharing vs immigration

```{r}

spagetti_epred_plot <- function(model,
                                effects,
                                drawcolour = "#bc4c66",
                                meancolour = "#deb78b",
                                text_colour = "#f2f2f2",
                                background = "transparent",
                                ndraws = 300,
                                resolution = 100) {
    model_cond_effs <- brms::conditional_effects(
        model,
        effects = effects,
        spaghetti = T,
        points = T,
        ndraws = ndraws,
        resolution = resolution,
        method = "posterior_epred"
    )

    model_df <- as.data.frame(model_cond_effs[[effects]])
    attr(model_df, "spaghetti") %>%
        ggplot() +
        geom_line(aes(
            x = effect1__,
            y = estimate__,
            group = sample__,
        ),
        alpha = .3, size = .3,
        colour = drawcolour
        ) +
        geom_smooth(
            data = model_df,
            aes(
                x = effect1__,
                y = estimate__,
            ),
            alpha = .8,
            size = 1,
            colour = meancolour
        ) +
        theme(
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.border = element_rect(colour = text_colour, fill = NA, size = 1),
            axis.ticks.y = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.x = element_text(colour = text_colour),
            axis.text.y = element_text(colour = text_colour),
            axis.title.y = element_text(
                colour = text_colour,
                margin = margin(t = 0, r = 10, b = 0, l = 0)
            ),
            axis.title.x = element_text(
                colour = text_colour,
                margin = margin(t = 10, r = 0, b = 0, l = 0)
            ),
            text = element_text(size = 9),
            plot.title = element_text(size = 14, face = "bold", colour = text_colour),
            plot.title.position = "panel",
            plot.subtitle = ggtext::element_markdown(size = 8, colour = text_colour),
            plot.caption = element_text(size = 8, hjust = 0),
            plot.caption.position = "plot",
            legend.key.width = unit(0.5, "cm"),
            legend.position = c(.9, .75),
            legend.background = element_rect(fill = background, color = NA),
            legend.box.background = element_rect(fill = background, color = NA),
            legend.text = element_text(color = text_colour),
            legend.title = element_text(color = text_colour),
            legend.key = element_blank(),
            panel.background = element_rect(fill = background, color = NA),
            plot.background = element_rect(fill = background, color = NA)
        ) +
        guides(
            size = "none",
        ) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) -> plot
    return(plot)
}
```

## Plot dyadic song-sharing vs immigration levels

```{r }
spagetti_epred_plot(m_0, "prop_immigrants",
    drawcolour = "#d34a4a",
    meancolour = "#deb78b", ndraws = 200,
    resolution = 100, background = "#262626"
) +
    labs(
        x = "Proportion of immigrant neighbours",
        y = "Song Sharing Index",
        title = "Song-sharing and immigration",
        subtitle = "*Posterior predictive distrib. of neighbour immigration status*<br>"
    ) -> imm_vs_sharing_m0

ggsave(
    filename = "imm_vs_sharing_m0.png",
    plot = imm_vs_sharing_m0,
    path = dirs$figs,
    scale = 1,
    width = 10,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```

## Plot song-sharing vs dispersal

```{r }
spagetti_epred_plot(m_1, "dispersal_distance",
    drawcolour = "#c0732c",
    meancolour = "#deb78b", ndraws = 300,
    resolution = 400, background = "#262626"
) +
    labs(
        x = "Mean dispersal distance of neighbours",
        y = "Song Sharing Index",
        title = "Song-sharing and dispersal",
        subtitle = "*Posterior predictive distrib. of dispersal distance*<br>"
    ) -> disp_vs_sharing_m1

ggsave(
    filename = "dispersal_vs_sharing_m0.png",
    plot = disp_vs_sharing_m0,
    path = dirs$figs,
    scale = 1,
    width = 10,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```



## Plot dyadic song-sharing vs spatial distance

```{r}

spagetti_epred_plot(m_7, "spatial_dist",
    drawcolour = "#bc4c66",
    meancolour = "#deb78b", ndraws = 200,
    resolution = 100, background = "#262626"
) +
    labs(
        x = "Distance (m)",
        y = "Repertoire Similarity",
        title = "Song similarity and spatial distance",
        subtitle = "*Posterior predictive distribution of spatial distance*<br>"
    ) -> dist_vs_sim_0_m7

ggsave(
    filename = "dist_vs_sim_0_m7.png",
    plot = dist_vs_sim_0_m7,
    path = dirs$figs,
    scale = 1,
    width = 10,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)


# kk = dist_vs_sim_m7 + dist_vs_sim_m7 & theme(
#     plot.background = element_rect(fill = "transparent", color = NA)
# )
```

## Plot posterior estimates of main effects
```{r posterior estimates}
# Check internal variable names
get_variables(m_3)
# Get samples from the posteriors
m_3_posteriors <- posterior_samples(m_3) %>%
    gather() %>%
    mutate(key = factor(key)) %>%
    filter(key != "b_Intercept", key != "lp__") %>%
    filter(key %in% c("b_immigration1", "sd_male_ring__Intercept", "b_year2021"))

# Order of variables in y axis
plt_order <- list(rev(c("b_immigration1", "b_year2021", "sd_male_ring__Intercept")), rev(c("Immigrant status", "Year", "SD Bird ID")))
# Plot
m_3_posteriors %>%
    ggplot(aes(x = value, y = fct_relevel(key, plt_order[[1]]))) +
    geom_vline(
        xintercept = 0,
        color = "grey",
        size = 1
    ) +
    stat_dotsinterval(
        point_interval = mode_hdi,
        .width = c(.90, .5), binwidth = 0.04,
        slab_color = "#2689a6",
        fill = "#2689a6",
        quantiles = 80,
        stackratio = 1
    ) +
    theme(
        panel.grid = element_blank(),
        aspect.ratio = 1
    ) +
    # coord_cartesian(xlim = c(0, 2.5), ylim = c(1.3, NA)) +
    scale_y_discrete(labels = plt_order[[2]]) +
    labs(
        y = NULL,
        x = "\nEstimate",
        title = "Posterior distribution of parameter estimates",
        subtitle = "Results of the bayesian regression model. <br>
        *repertoire_size ~
1 + immigrant + sampling_eff + year + s(x, y) + (1 | bird_id)*\n\n"
    ) +
    theme(
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(size = 12),
        plot.title = element_text(size = 14, face = "bold"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(size = 8, colour = "#363636"),
        plot.caption = element_text(size = 8, hjust = 0),
        plot.caption.position = "plot"
    ) -> posteriors_plot

ggsave(
    filename = "posterior_estimates_m_3.jpg",
    plot = posteriors_plot,
    path = dirs$figs,
    scale = 1,
    width = 13,
    height = 13,
    units = "cm",
    dpi = 300,
    limitsize = FALSE,
    bg = "transparent"
)
```

## Plot spatial effects


```{r}
#' Returns a tibble with conditional effects of spatial predictors.
#'
#' @param model An object of class brmsfit.
#' @param varnames A character vector naming effects.
#' @param resolution Number of points used.
#' @return A tibble containing estimates.
spatial_cond_effs <- function(model,
                              varnames = "x:y",
                              resolution = 200) {
    gp_plot <- conditional_effects(
        x = model,
        effects = varnames,
        ndraws = 500,
        resolution = resolution,
        surface = TRUE,
        robust = TRUE,
        points = TRUE,
        plot = FALSE
    )
    vars <- strsplit(varnames, split = ":")[[1]]
    spatdata <- plot(gp_plot, plot = FALSE, stype = "raster")
    estimates <- ggplot_build(spatdata[[1]])$plot$data %>%
        .[, c(vars[1], vars[2], "estimate__", "se__")] %>%
        as_tibble() %>%
        rename(estimate = estimate__, se = se__)

    return(estimates)
}


expand_rast <- function(df, axis = 0, position = "first") {
    uniquex <- unique(if (axis == 1) df$x else df$y)
    if (position == "first") {
        v <- min(if (axis == 1) df$x else df$y)
        xseq <- seq(v, v - 100, (uniquex[1] - uniquex[2]))
    } else if (position == "last") {
        v <- max(if (axis == 1) df$x else df$y)
        val0 <- v
        val1 <- val0 + 100
        xseq <- seq(val0, val1, -1 * (uniquex[1] - uniquex[2]))
    } else {
        stop("Position must be 'first' or 'last'")
    }
    ex <- df[if (axis == 1) df$x == v else df$y == v, ]
    if (axis == 1) {
        tobind <- tibble(
            x = rep(xseq, each = length(ex$y)),
            y = rep(ex$y, times = length(xseq))
        )
    } else {
        tobind <- tibble(
            y = rep(xseq, each = length(ex$y)),
            x = rep(ex$x, times = length(xseq))
        )
    }
    tobind <- tobind %>% mutate(
        estimate = rep(ex$estimate, times = length(xseq)),
        se = rep(ex$se, times = length(xseq))
    )
    return(tobind)
}
```

```{r }
# Read in woodland contour (with gaps)
epsg_code <- "epsg:27700"
perimeter <- vect(file.path(
    dirs$resources, "ww_contour", "wytham_perimeter.shp"
))
terra::crs(perimeter) <- epsg_code

# Used nestbox locations
nestbox_locs <- data %>% select(x, y)
```

```{r}
# Get estimates and mask to contour of study site

# 1. Conditional effects of Gaussian process

resolution <- 500
est <- spatial_cond_effs(
    m_3.1,
    varnames = "x:y",
    resolution = resolution
)

# Expand borders by repeating values:
margins <- list()
# ax[1, 0, 1, 0]
# for (i in 1:4) {
#     margins[[i]] <- expand_rast(est, axis = i, position = "first")
# }
margins[[1]] <- expand_rast(est, axis = 1, position = "first")
margins[[2]] <- expand_rast(est, axis = 0, position = "first")
margins[[3]] <- expand_rast(est, axis = 1, position = "last")
margins[[4]] <- expand_rast(est, axis = 0, position = "last")
margins[[5]] <- est
ex_est <- do.call(rbind, margins)

# 2. Mask
masked_rast <- rast(ex_est, type = "xyz") %>%
    terra::mask(., perimeter) %>%
    terra::as.data.frame(xy = TRUE) %>%
    as_tibble()
```
```{r}

x_max <- max(masked_rast$estimate)
x_min <- min(masked_rast$estimate)
colticks <- round(seq(f = x_min, t = x_max, by = 200), digits = 0)
text_colour <- "#f2f2f2"
ggplot() +
    geom_raster(data = masked_rast, aes(x = x, y = y, fill = estimate)) +
    geom_sf(
        data = sf::st_as_sf(perimeter), fill = NA,
        colour = text_colour, size = 0.3
    ) +
    # geom_point(
    #     data = data, aes(
    #         x = x, y = y
    #     ),
    #     pch = 21, fill = "white",
    #     color = "#ffffff", alpha = 0.4, size = 0.1
    # ) +
    # scale_size_continuous(range = c(0.5, 5)) +
    scale_fill_viridis_c(
        option = "magma",
        alpha = 1,
        name = "Estimate",
        breaks = colticks,
        guide = guide_colorbar(
            ticks = FALSE,
            nbin = 1000
        )
    ) +
    theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = text_colour, fill = NA, size = 1),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(colour = text_colour),
        axis.text.y = element_text(colour = text_colour),
        text = element_text(size = 8),
        plot.title = element_text(size = 14, face = "bold", colour = text_colour),
        plot.title.position = "panel",
        plot.subtitle = element_markdown(size = 8, colour = text_colour),
        plot.caption = element_text(size = 8, hjust = 0),
        plot.caption.position = "plot",
        legend.key.width = unit(0.5, "cm"),
        legend.position = c(.9, .75),
        legend.background = element_rect(fill = "transparent", color = NA),
        legend.box.background = element_rect(fill = "transparent", color = NA),
        legend.text = element_text(color = text_colour),
        legend.title = element_text(color = text_colour),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA)
    ) +
    guides(
        size = "none",
    ) +
    labs(
        x = NULL,
        y = NULL,
        title = "Levels of postnatal dispersal across space",
        subtitle = "*Posterior conditional effects of spatial predictor*<br>"
        # caption = "\nOther information"
    ) -> spatmarg
ggsave(
    filename = "spatial_m_3.1.png",
    plot = spatmarg,
    path = dirs$figs,
    scale = 1,
    width = 13,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```
### Plot posterior distribution of covariance
```{r }

post <-
    tidy_draws(m_2) %>%
    mutate(
        iter = 1:n(),
        etasq = sdgp_gpxy^2,
        rhosq = 1 / (2 * lscale_gpxy^2)
    )


# for `slice_sample()`
set.seed(14)

# wrangle

postd <- post %>%
    slice_sample(n = 150) %>%
    expand(nesting(iter, etasq, rhosq),
        x = seq(from = 0, to = 0.1, by = .001)
    ) %>%
    mutate(covariance = etasq * exp(-rhosq * x^2))
```


```{r }


drawcolour <- "#bc4c66"
meancolour <- "#deb78b"
text_colour <- "#f2f2f2"
background <- "transparent"


postd %>%
    # plot
    ggplot(aes(x = x, y = covariance)) +
    geom_line(aes(group = iter),
        alpha = .3, size = .3,
        colour = drawcolour
    ) +
    geom_smooth(
        # smooth jagged mean line (change to geom_line
        # to see that it has no effect otherwise)
        data = postd,
        aes(
            x = x,
            y = covariance,
        ),
        alpha = .8,
        size = 1,
        colour = meancolour,
        se = FALSE
    ) +
    #   scale_x_continuous("distance (thousand km)", expand = c(0, 0),
    #                      breaks = 0:5 * 2) +
    coord_cartesian(ylim = c(0, 1)) +
    theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = text_colour, fill = NA, size = 1),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_text(colour = text_colour),
        axis.text.y = element_text(colour = text_colour),
        axis.title.y = element_text(
            colour = text_colour,
            margin = margin(t = 0, r = 10, b = 0, l = 0)
        ),
        axis.title.x = element_text(
            colour = text_colour,
            margin = margin(t = 10, r = 0, b = 0, l = 0)
        ),
        text = element_text(size = 9),
        plot.title = element_text(size = 14, face = "bold", colour = text_colour),
        plot.title.position = "panel",
        plot.subtitle = ggtext::element_markdown(size = 8, colour = text_colour),
        plot.caption = element_text(size = 8, hjust = 0),
        plot.caption.position = "plot",
        legend.key.width = unit(0.5, "cm"),
        legend.position = c(.9, .75),
        legend.background = element_rect(fill = background, color = NA),
        legend.box.background = element_rect(fill = background, color = NA),
        legend.text = element_text(color = text_colour),
        legend.title = element_text(color = text_colour),
        legend.key = element_blank(),
        panel.background = element_rect(fill = background, color = NA),
        plot.background = element_rect(fill = background, color = NA)
    ) +
    guides(
        size = "none",
    ) +
    labs(
        x = "Distance",
        y = "Covariance",
        title = "Spatial covariance of song-sharing",
        subtitle = "*Posterior estimates from 2D GP*<br>"
        # caption = "\nOther information"
    ) -> spatcovar
ggsave(
    filename = "spatcovar.png",
    plot = spatcovar,
    path = dirs$figs,
    scale = 1,
    width = 10,
    height = 13,
    units = "cm",
    dpi = 350,
    limitsize = FALSE,
    bg = "transparent"
)
```

$male_ring$sd
           Estimate Est.Error       Q2.5    Q97.5
Intercept 0.5103354 0.2802164 0.02705899 1.015696